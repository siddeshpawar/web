<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Cipher Cryptography - Theory & Interactive Simulations</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <style>
        /* Override base styles for cryptography page */
        body {
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        /* Custom header for this page */
        .crypto-header {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .crypto-header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .crypto-nav-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .crypto-nav-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Main content container */
        .crypto-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Page header */
        .page-header {
            text-align: center;
            padding: 2rem 0;
            color: white;
        }

        .page-header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .page-header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .nav-btn:hover, .nav-btn.active {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .content {
            display: none;
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .content.active {
            display: block;
        }

        h2 {
            color: #4a5568;
            margin-bottom: 1.5rem;
            font-size: 2rem;
            position: relative;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 60px;
            height: 3px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 2px;
        }

        .theory-section, .simulation-section {
            margin: 2rem 0;
        }

        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 2rem 0;
        }

        .algorithm-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border-left: 5px solid #667eea;
            transition: transform 0.3s ease;
        }

        .algorithm-card:hover {
            transform: translateY(-5px);
        }

        .simulation-container {
            background: #2d3748;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            color: white;
        }

        .animation-area {
            height: 200px;
            border: 2px dashed #667eea;
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
            background: rgba(102, 126, 234, 0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        button:hover {
            background: #5a6fd8;
        }

        .output {
            background: #1a202c;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
        }

        .step {
            background: rgba(102, 126, 234, 0.2);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #667eea;
        }

        .key-exchange {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }

        .party {
            background: #667eea;
            color: white;
            padding: 15px;
            border-radius: 10px;
            width: 45%;
            text-align: center;
        }

        .arrow {
            font-size: 2rem;
            color: #667eea;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .stream-animation {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #ffd700;
            border-radius: 50%;
            animation: flow 3s linear infinite;
        }

        @keyframes flow {
            0% { left: -20px; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { left: 100%; opacity: 0; }
        }

        .bit-animation {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        @keyframes bitFlow {
            0% { left: -30px; top: 50%; }
            50% { left: 50%; top: 20%; }
            100% { left: 100%; top: 80%; }
        }

        .reg-animation {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .register {
            width: 40px;
            height: 40px;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            font-weight: bold;
        }

        .xor-animation {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .xor-box {
            width: 50px;
            height: 50px;
            background: #ff9800;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .flow-arrow {
            font-size: 1.5rem;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .nav {
                flex-direction: column;
                align-items: center;
            }

            .algorithm-grid {
                grid-template-columns: 1fr;
            }

            .key-exchange {
                flex-direction: column;
                gap: 20px;
            }

            .party {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <header class="crypto-header">
        <div class="container">
            <div style="display: flex; align-items: center; gap: 15px;">
                <button onclick="window.history.back()" class="crypto-nav-btn">
                    <i class="fas fa-arrow-left"></i> Back
                </button>
                <div style="color: white; font-size: 0.9rem; opacity: 0.9;">Stream Cipher Cryptography Guide</div>
            </div>
            <div style="display: flex; gap: 10px;">
                <a href="news.html" class="crypto-nav-btn">
                    <i class="fas fa-newspaper"></i> News
                </a>
                <a href="index.html" class="crypto-nav-btn">
                    <i class="fas fa-home"></i> Home
                </a>
            </div>
        </div>
    </header>

    <div class="crypto-container">
        <div class="page-header">
            <h1>üîê Stream Cipher Cryptography</h1>
            <p class="subtitle">Interactive Theory & Protocol Simulations</p>
        </div>

        <nav class="nav">
            <button class="nav-btn active" onclick="showContent('stream-theory')">Stream Cipher Theory</button>
            <button class="nav-btn" onclick="showContent('a51')">A5/1 (GSM)</button>
            <button class="nav-btn" onclick="showContent('e0')">E0 (Bluetooth)</button>
            <button class="nav-btn" onclick="showContent('chacha20')">ChaCha20 (TLS 1.3)</button>
            <button class="nav-btn" onclick="showContent('rc4')">RC4 (WEP/TLS/SSL)</button>
        </nav>

        <!-- Stream Cipher Theory Section -->
        <div id="stream-theory" class="content active">
            <h2>üìö Stream Cipher Theory</h2>

            <div class="theory-section">
                <h3>What are Stream Ciphers?</h3>
                <p>Stream ciphers are symmetric encryption algorithms that encrypt plaintext one bit or byte at a time using a pseudorandom keystream. Unlike block ciphers that operate on fixed-size blocks, stream ciphers generate a continuous stream of key material that's XORed with the plaintext.</p>

                <div class="algorithm-card">
                    <h4>üîë Key Components</h4>
                    <ul>
                        <li><strong>Keystream Generator:</strong> Produces pseudorandom bits</li>
                        <li><strong>Key & IV:</strong> Secret key and initialization vector</li>
                        <li><strong>XOR Operation:</strong> Combines plaintext with keystream</li>
                        <li><strong>Synchronous/Asynchronous:</strong> Clock-controlled or self-synchronizing</li>
                    </ul>
                </div>

                <div class="simulation-container">
                    <h4>üìê Stream Cipher Mathematical Foundation</h4>
                    <div class="step-indicator" style="margin-bottom: 20px;">
                        <strong>Encryption:</strong> C<sub>i</sub> = P<sub>i</sub> ‚äï K<sub>i</sub><br>
                        <strong>Decryption:</strong> P<sub>i</sub> = C<sub>i</sub> ‚äï K<sub>i</sub><br>
                        Where K is the keystream generated from key and IV
                    </div>
                    <div style="background: #2d3748; padding: 20px; border-radius: 10px; margin: 15px 0;">
                        <h5 style="color: #ffd700; margin-bottom: 15px;">Keystream Generation</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
                            <div style="margin: 8px 0;">1. <strong>Key Schedule:</strong> Expand key + IV into initial state</div>
                            <div style="margin: 8px 0;">2. <strong>State Update:</strong> Apply mixing function f: S<sub>i+1</sub> = f(S<sub>i</sub>)</div>
                            <div style="margin: 8px 0;">3. <strong>Output Function:</strong> K<sub>i</sub> = g(S<sub>i</sub>)</div>
                            <div style="margin: 8px 0;">4. <strong>Periodicity:</strong> State must have long cycle length</div>
                        </div>
                    </div>
                    <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #667eea; margin-bottom: 10px;">Security Requirements</h5>
                        <ul style="margin-left: 20px; line-height: 1.8;">
                            <li><strong>Long Period:</strong> 2<sup>n</sup> where n is state size</li>
                            <li><strong>Linear Complexity:</strong> ‚âà n/2 (ideal for LFSR-based)</li>
                            <li><strong>Statistical Properties:</strong> Passes all randomness tests</li>
                            <li><strong>Key Sensitivity:</strong> 1-bit change ‚Üí 50% output difference</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- A5/1 Section -->
        <div id="a51" class="content">
            <h2>üì± A5/1 Stream Cipher (GSM)</h2>

            <div class="theory-section">
                <h3>Overview</h3>
                <p>A5/1 is a stream cipher used to encrypt GSM cellular communications. It was developed in 1987 and uses three linear feedback shift registers (LFSRs) of different lengths combined with irregular clocking for enhanced security.</p>

                <div class="algorithm-card">
                    <h4>üìã A5/1 Specifications</h4>
                    <ul>
                        <li><strong>Key Length:</strong> 64 bits (54 effective)</li>
                        <li><strong>Frame Size:</strong> 114 bits</li>
                        <li><strong>LFSRs:</strong> 19-bit, 22-bit, 23-bit</li>
                        <li><strong>Clocking:</strong> Majority rule based</li>
                    </ul>
                </div>

                <div class="simulation-container">
                    <h4>üìê A5/1 Mathematical Structure</h4>
                    <div style="background: #2d3748; padding: 20px; border-radius: 10px; margin: 15px 0;">
                        <h5 style="color: #ffd700; margin-bottom: 15px;">LFSR Specifications</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                            <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
                                <h6 style="color: #4CAF50; margin-bottom: 10px;">R1 (19-bit LFSR)</h6>
                                <div style="font-family: 'Courier New', monospace; font-size: 0.8rem;">
                                    Length: 19 bits<br>
                                    Feedback: x<sup>19</sup> + x<sup>18</sup> + x<sup>17</sup> + x<sup>14</sup> + 1<br>
                                    Taps: positions 18, 17, 16, 13<br>
                                    Output: bit 18
                                </div>
                            </div>
                            <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
                                <h6 style="color: #2196F3; margin-bottom: 10px;">R2 (22-bit LFSR)</h6>
                                <div style="font-family: 'Courier New', monospace; font-size: 0.8rem;">
                                    Length: 22 bits<br>
                                    Feedback: x<sup>22</sup> + x<sup>21</sup> + 1<br>
                                    Taps: positions 21, 20<br>
                                    Output: bit 21
                                </div>
                            </div>
                            <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px;">
                                <h6 style="color: #FF9800; margin-bottom: 10px;">R3 (23-bit LFSR)</h6>
                                <div style="font-family: 'Courier New', monospace; font-size: 0.8rem;">
                                    Length: 23 bits<br>
                                    Feedback: x<sup>23</sup> + x<sup>22</sup> + x<sup>21</sup> + x<sup>8</sup> + 1<br>
                                    Taps: positions 22, 21, 20, 7<br>
                                    Output: bit 22
                                </div>
                            </div>
                        </div>
                    </div>
                    <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #667eea; margin-bottom: 10px;">Clocking Mechanism</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
                            <div style="margin: 5px 0;">Majority = floor((R1<sub>8</sub> + R2<sub>10</sub> + R3<sub>10</sub>) / 2)</div>
                            <div style="margin: 5px 0;">if R1<sub>8</sub> = Majority: Clock R1</div>
                            <div style="margin: 5px 0;">if R2<sub>10</sub> = Majority: Clock R2</div>
                            <div style="margin: 5px 0;">if R3<sub>10</sub> = Majority: Clock R3</div>
                            <div style="margin: 5px 0;">Keystream bit = R1<sub>18</sub> ‚äï R2<sub>21</sub> ‚äï R3<sub>22</sub></div>
                        </div>
                    </div>
                    <div style="background: rgba(231, 76, 60, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Mathematical Properties</h5>
                        <ul style="margin-left: 20px; line-height: 1.8;">
                            <li><strong>State Space:</strong> 2<sup>19+22+23</sup> = 2<sup>64</sup> ‚âà 1.8 √ó 10<sup>19</sup> states</li>
                            <li><strong>Period:</strong> LCM of individual LFSR periods</li>
                            <li><strong>Linear Complexity:</strong> Complex due to irregular clocking</li>
                            <li><strong>Security:</strong> Vulnerable to time-memory tradeoffs</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- E0 Section -->
        <div id="e0" class="content">
            <h2>üî∑ E0 Stream Cipher (Bluetooth)</h2>

            <div class="theory-section">
                <h3>Overview</h3>
                <p>E0 is the encryption algorithm used in Bluetooth systems for securing wireless communications between devices. It uses a combination of linear feedback shift registers and finite state machines to generate the keystream.</p>

                <div class="algorithm-card">
                    <h4>üìã E0 Specifications</h4>
                    <ul>
                        <li><strong>Key Length:</strong> Up to 128 bits</li>
                        <li><strong>Architecture:</strong> Four LFSRs + FSM</li>
                        <li><strong>Frame:</strong> Variable length</li>
                        <li><strong>Standard:</strong> Bluetooth BR/EDR</li>
                    </ul>
                </div>

                <div class="simulation-container">
                    <h4>üé¨ E0 Key Exchange Simulation</h4>
                    <div class="key-exchange">
                        <div class="party">
                            <h4>Device A</h4>
                            <p>Master Key: <span id="master-key-a">0x1234ABCD</span></p>
                            <p>Address: <span id="addr-a">00:11:22:33:44:55</span></p>
                        </div>
                        <div class="arrow">‚ÜîÔ∏è</div>
                        <div class="party">
                            <h4>Device B</h4>
                            <p>Master Key: <span id="master-key-b">0x5678EFGH</span></p>
                            <p>Address: <span id="addr-b">66:77:88:99:AA:BB</span></p>
                        </div>
                    </div>
                    <div class="animation-area" id="e0-animation">
                        <div class="bit-animation" id="e0-bit-1">0</div>
                        <div class="bit-animation" id="e0-bit-2">1</div>
                        <div class="bit-animation" id="e0-bit-3">0</div>
                        <div class="bit-animation" id="e0-bit-4">1</div>
                    </div>
                    <div class="controls">
                        <button onclick="simulateE0()">Generate Keystream</button>
                        <button onclick="resetE0()">Reset</button>
                    </div>
                    <div class="output" id="e0-output"></div>
                </div>
            </div>
        </div>

        <!-- ChaCha20 Section -->
        <div id="chacha20" class="content">
            <h2>üå™Ô∏è ChaCha20 (TLS 1.3)</h2>

            <div class="theory-section">
                <h3>Overview</h3>
                <p>ChaCha20 is a modern stream cipher designed by Daniel J. Bernstein. It's used in TLS 1.3 as an alternative to AES, particularly on systems where AES hardware acceleration isn't available. ChaCha20 is based on the ChaCha permutation and provides excellent performance and security.</p>

                <div class="algorithm-card">
                    <h4>üìã ChaCha20 Specifications</h4>
                    <ul>
                        <li><strong>Key Length:</strong> 256 bits</li>
                        <li><strong>Nonce:</strong> 96 bits</li>
                        <li><strong>Block Size:</strong> 512 bits</li>
                        <li><strong>Rounds:</strong> 20 (ChaCha20)</li>
                        <li><strong>Security:</strong> Post-quantum resistant design</li>
                    </ul>
                </div>

                <div class="simulation-container">
                    <h4>üìê ChaCha20 Mathematical Operations</h4>
                    <div style="background: #2d3748; padding: 20px; border-radius: 10px; margin: 15px 0;">
                        <h5 style="color: #ffd700; margin-bottom: 15px;">State Matrix (4√ó4 array of 32-bit words)</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.8rem; line-height: 1.8; text-align: center;">
                            <div style="display: inline-block; border: 2px solid #ffd700; padding: 10px;">
                                <div>œÉ<sub>0</sub>    œÉ<sub>1</sub>    œÉ<sub>2</sub>    œÉ<sub>3</sub></div>
                                <div>K<sub>0</sub>    K<sub>1</sub>    K<sub>2</sub>    K<sub>3</sub></div>
                                <div>K<sub>4</sub>    K<sub>5</sub>    K<sub>6</sub>    K<sub>7</sub></div>
                                <div>C<sub>0</sub>    C<sub>1</sub>    N<sub>0</sub>    N<sub>1</sub></div>
                            </div>
                            <div style="margin-top: 15px;">
                                Where œÉ = "expand 32-byte k", C = 32-bit counter, N = 96-bit nonce
                            </div>
                        </div>
                    </div>
                    <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #667eea; margin-bottom: 10px;">Quarter Round Function</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
                            <div style="margin: 8px 0;">QR(a, b, c, d):</div>
                            <div style="margin: 8px 0; padding-left: 20px;">a += b;  d ‚äï= a;  d ‚â™= 16;</div>
                            <div style="margin: 8px 0; padding-left: 20px;">c += d;  b ‚äï= c;  b ‚â™= 12;</div>
                            <div style="margin: 8px 0; padding-left: 20px;">a += b;  d ‚äï= a;  d ‚â™= 8;</div>
                            <div style="margin: 8px 0; padding-left: 20px;">c += d;  b ‚äï= c;  b ‚â™= 7;</div>
                        </div>
                        <div style="margin-top: 15px; font-size: 0.9rem;">
                            <strong>Column Round:</strong> QR(0,4,8,12), QR(1,5,9,13), QR(2,6,10,14), QR(3,7,11,15)<br>
                            <strong>Diagonal Round:</strong> QR(0,5,10,15), QR(1,6,11,12), QR(2,7,8,13), QR(3,4,9,14)
                        </div>
                    </div>
                    <div style="background: rgba(155, 89, 182, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #9b59b6; margin-bottom: 10px;">ChaCha20 Algorithm</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.8rem; line-height: 1.8;">
                            <div>1. Initialize 16-word state matrix</div>
                            <div>2. Copy state to working buffer</div>
                            <div>3. for round = 1 to 10:</div>
                            <div style="padding-left: 20px;">Apply column round to working buffer</div>
                            <div style="padding-left: 20px;">Apply diagonal round to working buffer</div>
                            <div>4. Add working buffer back to state</div>
                            <div>5. Serialize state to keystream</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- RC4 Section -->
        <div id="rc4" class="content">
            <h2>üîÑ RC4 (WEP/TLS/SSL)</h2>

            <div class="theory-section">
                <h3>Overview</h3>
                <p>RC4 (Rivest Cipher 4) is one of the most widely used stream ciphers, particularly known for its implementation in WEP for wireless security and early versions of TLS/SSL. Despite its speed and simplicity, RC4 has several cryptographic weaknesses that have led to its deprecation.</p>

                <div class="algorithm-card">
                    <h4>‚ö†Ô∏è RC4 Vulnerabilities</h4>
                    <ul>
                        <li><strong>Bias Attacks:</strong> Key scheduling weaknesses</li>
                        <li><strong>Fluhrer-Mantin-Shamir:</strong> Distinguishes RC4 from random</li>
                        <li><strong>Key Recovery:</strong> Related key attacks possible</li>
                        <li><strong>Status:</strong> Deprecated for new systems</li>
                    </ul>
                </div>

                <div class="simulation-container">
                    <h4>üìê RC4 Mathematical Algorithm</h4>
                    <div style="background: #2d3748; padding: 20px; border-radius: 10px; margin: 15px 0;">
                        <h5 style="color: #ffd700; margin-bottom: 15px;">Key Scheduling Algorithm (KSA)</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
                            <div style="margin: 8px 0;">1. S[0..255] = [0, 1, 2, ..., 255]</div>
                            <div style="margin: 8px 0;">2. j = 0</div>
                            <div style="margin: 8px 0;">3. for i = 0 to 255:</div>
                            <div style="margin: 8px 0; padding-left: 20px;">j = (j + S[i] + key[i mod keylen]) mod 256</div>
                            <div style="margin: 8px 0; padding-left: 20px;">swap(S[i], S[j])</div>
                        </div>
                    </div>
                    <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #667eea; margin-bottom: 10px;">Pseudo-Random Generation Algorithm (PRGA)</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
                            <div style="margin: 8px 0;">1. i = 0, j = 0</div>
                            <div style="margin: 8px 0;">2. while generating output:</div>
                            <div style="margin: 8px 0; padding-left: 20px;">i = (i + 1) mod 256</div>
                            <div style="margin: 8px 0; padding-left: 20px;">j = (j + S[i]) mod 256</div>
                            <div style="margin: 8px 0; padding-left: 20px;">swap(S[i], S[j])</div>
                            <div style="margin: 8px 0; padding-left: 20px;">output = S[(S[i] + S[j]) mod 256]</div>
                        </div>
                    </div>
                    <div style="background: rgba(231, 76, 60, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #e74c3c; margin-bottom: 10px;">Mathematical Properties</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.8rem; line-height: 1.8;">
                            <div><strong>Key Length:</strong> Variable (typically 40-256 bits)</div>
                            <div><strong>State Size:</strong> 256 bytes (2048 bits)</div>
                            <div><strong>Period:</strong> ‚âà 2<sup>2048</sup> (theoretically)</div>
                            <div><strong>Output:</strong> S[(S[i] + S[j]) mod 256]</div>
                            <div><strong>Vulnerability:</strong> Key scheduling biases in first 256 bytes</div>
                        </div>
                    </div>
                    <div style="background: rgba(155, 89, 182, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h5 style="color: #9b59b6; margin-bottom: 10px;">RC4 Encryption/Decryption</h5>
                        <div style="font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6;">
                            <div style="margin: 8px 0;">C<sub>i</sub> = P<sub>i</sub> ‚äï K<sub>i</sub></div>
                            <div style="margin: 8px 0;">P<sub>i</sub> = C<sub>i</sub> ‚äï K<sub>i</sub></div>
                            <div style="margin: 8px 0;">Where K is the keystream from PRGA</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function showContent(sectionId) {
            // Hide all content sections
            const contents = document.querySelectorAll('.content');
            contents.forEach(content => content.classList.remove('active'));

            // Remove active class from all nav buttons
            const navBtns = document.querySelectorAll('.nav-btn');
            navBtns.forEach(btn => btn.classList.remove('active'));

            // Show selected content section
            document.getElementById(sectionId).classList.add('active');

            // Add active class to clicked nav button
            event.target.classList.add('active');
        }

        function startAnimation(animationId) {
            const animation = document.getElementById(animationId);
            animation.style.animationPlayState = 'running';
        }

        function pauseAnimation() {
            const animations = document.querySelectorAll('.animation-area');
            animations.forEach(anim => {
                anim.style.animationPlayState = 'paused';
            });
        }

        function resetAnimation() {
            location.reload();
        }

        // A5/1 Simulation with detailed LFSR animation
        let a51Step = 0;
        const lfsr19 = [1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,1,0,0];
        const lfsr22 = [0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,1,0,1,0,1,1];
        const lfsr23 = [1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,0,1,0];
        
        function stepA51() {
            if (a51Step >= 10) return;
            
            // Update step indicator
            document.getElementById('a51-step').innerHTML = `Step ${a51Step + 1}: Clock LFSRs based on majority rule`;
            
            // Determine which registers clock (majority of middle bits)
            const majority = Math.floor((lfsr19[8] + lfsr22[10] + lfsr23[10]) / 2);
            
            // Clock registers where middle bit matches majority
            if (lfsr19[8] === majority) {
                // Clock 19-bit LFSR: new_bit = feedback XOR positions 18,17,16,13
                const newBit19 = lfsr19[18] ^ lfsr19[17] ^ lfsr19[16] ^ lfsr19[13];
                lfsr19.pop(); // Remove last bit
                lfsr19.unshift(newBit19); // Add new bit at beginning
                highlightBits('lfsr19', [13, 16, 17, 18]);
            }
            
            if (lfsr22[10] === majority) {
                // Clock 22-bit LFSR: new_bit = feedback XOR positions 21,20
                const newBit22 = lfsr22[21] ^ lfsr22[20];
                lfsr22.pop();
                lfsr22.unshift(newBit22);
                highlightBits('lfsr22', [20, 21]);
            }
            
            if (lfsr23[10] === majority) {
                // Clock 23-bit LFSR: new_bit = feedback XOR positions 22,21,20,7
                const newBit23 = lfsr23[22] ^ lfsr23[21] ^ lfsr23[20] ^ lfsr23[7];
                lfsr23.pop();
                lfsr23.unshift(newBit23);
                highlightBits('lfsr23', [7, 20, 21, 22]);
            }
            
            // Update display
            updateLFSRDisplay('lfsr19', lfsr19);
            updateLFSRDisplay('lfsr22', lfsr22);
            updateLFSRDisplay('lfsr23', lfsr23);
            
            // XOR the output bits
            const xorResult = lfsr19[18] ^ lfsr22[21] ^ lfsr23[22];
            document.getElementById('xor-input-1').innerHTML = lfsr19[18];
            document.getElementById('xor-input-2').innerHTML = lfsr22[21];
            document.getElementById('xor-input-3').innerHTML = lfsr23[22];
            document.getElementById('xor-output').innerHTML = xorResult;
            
            // Update output
            const output = document.getElementById('a51-output');
            if (a51Step === 0) {
                output.innerHTML = '';
            }
            output.innerHTML += `<div class="step">Step ${a51Step + 1}: Generated bit = ${xorResult}</div>`;
            
            a51Step++;
        }
        
        function updateLFSRDisplay(registerId, bits) {
            for (let i = 0; i < bits.length; i++) {
                const bitElement = document.getElementById(`${registerId}-${i}`);
                if (bitElement) {
                    bitElement.innerHTML = bits[i];
                }
            }
        }
        
        function highlightBits(registerId, positions) {
            positions.forEach(pos => {
                const bitElement = document.getElementById(`${registerId}-${pos}`);
                if (bitElement) {
                    bitElement.classList.add('tapped');
                    setTimeout(() => {
                        bitElement.classList.remove('tapped');
                    }, 1000);
                }
            });
        }
        
        function autoA51() {
            const interval = setInterval(() => {
                stepA51();
                if (a51Step >= 10) {
                    clearInterval(interval);
                }
            }, 1500);
        }
        
        function resetA51() {
            a51Step = 0;
            document.getElementById('a51-step').innerHTML = 'Step 1: Initialize LFSRs with key bits';
            document.getElementById('a51-output').innerHTML = '';
            updateLFSRDisplay('lfsr19', [1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,1,0,0]);
            updateLFSRDisplay('lfsr22', [0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,1,0,1,0,1,1]);
            updateLFSRDisplay('lfsr23', [1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,0,1,0]);
            document.getElementById('xor-input-1').innerHTML = '0';
            document.getElementById('xor-input-2').innerHTML = '1';
            document.getElementById('xor-input-3').innerHTML = '0';
            document.getElementById('xor-output').innerHTML = '1';
        }
        
        // ChaCha20 Quarter Round Animation
        let chachaStep = 0;
        const initialState = [
            [0x61707865, 0x3320646E, 0x79622D32, 0x6B206574],
            [0x00000000, 0x00000000, 0x00000000, 0x00000000],
            [0x00000000, 0x00000000, 0x00000000, 0x00000000],
            [0x00000000, 0x00000000, 0x00000000, 0x00000001]
        ];
        let currentState = JSON.parse(JSON.stringify(initialState));
        
        function stepChaCha20() {
            if (chachaStep >= 4) return;
            
            document.getElementById('chacha-step').innerHTML = `Step ${chachaStep + 1}: Quarter round operation`;
            
            const operations = [
                'a += b; d ^= a; d &lt;&lt;= 16;',
                'c += d; b ^= c; b &lt;&lt;= 12;',
                'a += b; d ^= a; d &lt;&lt;= 8;',
                'c += d; b ^= c; b &lt;&lt;= 7;'
            ];
            
            document.getElementById('quarter-round').innerHTML = operations[chachaStep];
            
            // Simulate the quarter round on first word (indices 0,4,8,12)
            let a = currentState[0][0];
            let b = currentState[1][0];
            let c = currentState[2][0];
            let d = currentState[3][0];
            
            if (chachaStep === 0) {
                a = (a + b) >>> 0;
                d = (d ^ a) >>> 0;
                d = ((d << 16) | (d >>> 16)) >>> 0;
                document.getElementById('c00').innerHTML = `0x${a.toString(16).padStart(8, '0')}`;
                document.getElementById('c30').innerHTML = `0x${d.toString(16).padStart(8, '0')}`;
                currentState[0][0] = a;
                currentState[3][0] = d;
            } else if (chachaStep === 1) {
                c = (c + d) >>> 0;
                b = (b ^ c) >>> 0;
                b = ((b << 12) | (b >>> 20)) >>> 0;
                document.getElementById('c10').innerHTML = `0x${b.toString(16).padStart(8, '0')}`;
                document.getElementById('c20').innerHTML = `0x${c.toString(16).padStart(8, '0')}`;
                currentState[1][0] = b;
                currentState[2][0] = c;
            } else if (chachaStep === 2) {
                a = (a + b) >>> 0;
                d = (d ^ a) >>> 0;
                d = ((d << 8) | (d >>> 24)) >>> 0;
                document.getElementById('c00').innerHTML = `0x${a.toString(16).padStart(8, '0')}`;
                document.getElementById('c30').innerHTML = `0x${d.toString(16).padStart(8, '0')}`;
                currentState[0][0] = a;
                currentState[3][0] = d;
            } else if (chachaStep === 3) {
                c = (c + d) >>> 0;
                b = (b ^ c) >>> 0;
                b = ((b << 7) | (b >>> 25)) >>> 0;
                document.getElementById('c10').innerHTML = `0x${b.toString(16).padStart(8, '0')}`;
                document.getElementById('c20').innerHTML = `0x${c.toString(16).padStart(8, '0')}`;
                currentState[1][0] = b;
                currentState[2][0] = c;
            }
            
            const output = document.getElementById('chacha-output');
            output.innerHTML += `<div class="step">After operation ${chachaStep + 1}: State updated</div>`;
            
            chachaStep++;
        }
        
        function autoChaCha20() {
            const interval = setInterval(() => {
                stepChaCha20();
                if (chachaStep >= 4) {
                    clearInterval(interval);
                }
            }, 2000);
        }
        
        function resetChaCha20() {
            chachaStep = 0;
            currentState = JSON.parse(JSON.stringify(initialState));
            document.getElementById('chacha-step').innerHTML = 'Step 1: Initialize state matrix';
            document.getElementById('quarter-round').innerHTML = 'a += b; d ^= a; d &lt;&lt;= 16;&lt;br&gt;c += d; b ^= c; b &lt;&lt;= 12;&lt;br&gt;a += b; d ^= a; d &lt;&lt;= 8;&lt;br&gt;c += d; b ^= c; b &lt;&lt;= 7;';
            document.getElementById('c00').innerHTML = '0x61707865';
            document.getElementById('c01').innerHTML = '0x3320646E';
            document.getElementById('c02').innerHTML = '0x79622D32';
            document.getElementById('c03').innerHTML = '0x6B206574';
            document.getElementById('c10').innerHTML = '0x00000000';
            document.getElementById('c11').innerHTML = '0x00000000';
            document.getElementById('c12').innerHTML = '0x00000000';
            document.getElementById('c13').innerHTML = '0x00000000';
            document.getElementById('c20').innerHTML = '0x00000000';
            document.getElementById('c21').innerHTML = '0x00000000';
            document.getElementById('c22').innerHTML = '0x00000000';
            document.getElementById('c23').innerHTML = '0x00000000';
            document.getElementById('c30').innerHTML = '0x00000000';
            document.getElementById('c31').innerHTML = '0x00000000';
            document.getElementById('c32').innerHTML = '0x00000000';
            document.getElementById('c33').innerHTML = '0x00000001';
            document.getElementById('chacha-output').innerHTML = '';
        }
        
        // RC4 Key Scheduling Algorithm Animation
        let rc4Step = 0;
        let sArray = Array.from({length: 256}, (_, i) => i);
        const key = [83, 69, 67, 82, 69, 84, 75, 69, 89]; // "SECRETKEY"
        let i = 0;
        let j = 0;
        
        function stepRC4() {
            if (rc4Step >= 20) return;
            
            document.getElementById('rc4-step').innerHTML = `Step ${rc4Step + 1}: i=${i}, j=${j}`;
            
            // RC4 Key Scheduling Algorithm
            i = (i + 1) % 256;
            j = (j + sArray[i] + key[i % key.length]) % 256;
            
            // Swap S[i] and S[j]
            const temp = sArray[i];
            sArray[i] = sArray[j];
            sArray[j] = temp;
            
            // Update display for first 16 elements
            for (let k = 0; k < 16; k++) {
                const cell = document.getElementById(`s-${k}`);
                if (cell) {
                    if (k === i || k === j) {
                        cell.classList.add('swap');
                        cell.innerHTML = sArray[k];
                    } else {
                        cell.classList.remove('swap');
                        cell.innerHTML = sArray[k];
                    }
                }
            }
            
            // Update key mixing indicator
            document.getElementById('key-mixing').innerHTML = `i = ${i}, j = (j + S[${i}] + key[${i % key.length}]) mod 256 = ${j}&lt;br&gt;S[${i}] ‚Üî S[${j}]`;
            
            const output = document.getElementById('rc4-output');
            output.innerHTML += `<div class="step">After step ${rc4Step + 1}: S[${i}] = ${sArray[i]}, S[${j}] = ${sArray[j]}</div>`;
            
            rc4Step++;
        }
        
        function autoRC4() {
            const interval = setInterval(() => {
                stepRC4();
                if (rc4Step >= 20) {
                    clearInterval(interval);
                }
            }, 1000);
        }
        
        function resetRC4() {
            rc4Step = 0;
            i = 0;
            j = 0;
            sArray = Array.from({length: 256}, (_, i) => i);
            document.getElementById('rc4-step').innerHTML = 'Step 1: Initialize S[0..255] = 0..255';
            document.getElementById('key-mixing').innerHTML = 'i = 0, j = 0&lt;br&gt;S[i] ‚Üî S[j] where j = (j + S[i] + key[i mod keylen]) mod 256';
            
            // Reset first 16 elements display
            for (let k = 0; k < 16; k++) {
                const cell = document.getElementById(`s-${k}`);
                if (cell) {
                    cell.classList.remove('swap');
                    cell.innerHTML = k;
                }
            }
            
            document.getElementById('rc4-output').innerHTML = '';
        }
        
        // Legacy functions for compatibility
        function simulateA51() { stepA51(); }
        function simulateE0() { document.getElementById('e0-output').innerHTML = '<div class="step">E0 animation would show LFSR combinations...</div>'; }
        function simulateChaCha20() { stepChaCha20(); }
        function simulateRC4() { stepRC4(); }
    </script>
    <script src="assets/js/main.js"></script>
</body>
</html>
